{
	"version": 3,
	"file": "/home/steinar/source/Transcrypt/transcrypt/modules/re/__javascript__/re.mod.js",
	"sources": [
		"/home/steinar/source/Transcrypt/transcrypt/modules/re/__init__.py"
	],
	"sourcesContent": [
		"# File: transcript/modules/re/__init__.py\n# Author: Carl Allendorph\n# Date: 13NOV2016\n#\n# Description:\n#    This file contains the definition of a simulated re python\n# regular expression parsing module. The idea is to leverage the\n# javascript native regular expression interface as much as\n# possible. In fact, where necessary, this module chooses the\n# javascript idiosyncracies over the python ones.\n#\n#\n\nfrom org.transcrypt.stubs.browser import __pragma__\nfrom re.translate import translate\n\n\n# Flags\n\nT = (1<<0)\nTEMPLATE = T\n\nI = (1<<1)\nIGNORECASE = I\n\n# Deprecated\nL = (1<<2)\nLOCALE = L\n\nM = (1<<3)\nMULTILINE = M\n\nS = (1 << 4)\nDOTALL = S\n# Legacy - Unicode by default in Python 3\nU = (1 << 5)\nUNICODE = U\nX = (1 << 6)\nVERBOSE = X\nDEBUG = (1<<7)\n\nA = (1<<8)\nASCII = A\n\n# This is a javascript specific flag\nY = (1 << 16)\nSTICKY = Y\nG = (1 << 17)\nGLOBAL = G\n# This flag is used to indicate that re module should use\n# the javascript regex engine directly and not attempt to\n# translate the regex string into a python regex\nJ = (1<<19)\nJSSTRICT = J\n\n\n\nclass error(Exception):\n    \"\"\" Regular Expression Exception Class\n    \"\"\"\n    def __init__(self, msg, error, pattern = None, flags = 0, pos = None):\n        \"\"\"\n        \"\"\"\n        Exception.__init__(self, msg, error=error)\n        self.pattern = pattern\n        self.flags = flags\n        self.pos = pos\n        # @todo - lineno and colno attributes\n\nclass ReIndexError(IndexError):\n    \"\"\" Index Error variant for the re module - primarily used for\n    the group method in the Match Object.\n    \"\"\"\n    def __init__(self):\n        IndexError.__init__(self, \"no such group\")\n\nclass Match(object):\n    \"\"\" Resulting Match from a Regex Operation\n    \"\"\"\n    def __init__(self, mObj, string, pos, endpos, rObj, namedGroups = None):\n        \"\"\"\n        \"\"\"\n        # JS has two \"None\" values: `null` and `undefined`.\n        # `x is None` converts to `x === null`, which will fail if `x` is undefined.\n        # The js match object uses undefined for non-used capture groups,\n        # so it's not possible to find non-used groups by comparing with `None`,\n        # unless this conversion is made.\n        for index, match in enumerate(mObj):\n            mObj[index] = None if mObj[index] == js_undefined else mObj[index]\n        self._obj = mObj\n\n        self._pos = pos\n        self._endpos = endpos\n        self._re = rObj\n        self._string = string\n\n        self._namedGroups = namedGroups\n\n        self._lastindex = self._lastMatchGroup()\n        if ( self._namedGroups is not None ):\n            self._lastgroup = self._namedGroups[self._lastindex]\n        else:\n            # @note - javascript does not have the concept\n            #       of named groups so we will never be able to\n            #       implement this in raw RegExp\n            self._lastgroup = None\n\n    # Read-only Properties\n    def _getPos(self):\n        return(self._pos)\n    def _setPos(self, val):\n        raise AttributeError(\"readonly attribute\")\n    pos = property(_getPos, _setPos)\n\n    def _getEndPos(self):\n        return(self._endpos)\n    def _setEndPos(self, val):\n        raise AttributeError(\"readonly attribute\")\n    endpos = property(_getEndPos, _setEndPos)\n\n    def _getRe(self):\n        return(self._re)\n    def _setRe(self, val):\n        raise AttributeError(\"readonly attribute\")\n    re = property(_getRe, _setRe)\n\n    def _getString(self):\n        return(self._string)\n    def _setString(self, val):\n        raise AttributeError(\"readonly attribute\")\n    string = property(_getString, _setString)\n\n    def _getLastGroup(self):\n        return(self._lastgroup)\n    def _setLastGroup(self, val):\n        raise AttributeError(\"readonly attribute\")\n    lastgroup = property(_getLastGroup, _setLastGroup)\n\n    def _getLastIndex(self):\n        return(self._lastindex)\n    def _setLastIndex(self, val):\n        raise AttributeError(\"readonly attribute\")\n    lastindex = property(_getLastIndex, _setLastIndex)\n\n    def _lastMatchGroup(self):\n        \"\"\" Determine the last matching group in the object\n        \"\"\"\n        if ( len(self._obj) > 1 ):\n            for i in range(len(self._obj)-1,0,-1):\n                if (self._obj[i] is not None):\n                    return(i)\n            # None of the capture groups matched -\n            # this seems like it shouldn't happen\n            return(None)\n        else:\n            # No Capture Groups\n            return(None)\n\n    def expand(self, template):\n        \"\"\"\n        \"\"\"\n        raise NotImplementedError()\n\n    def group(self, *args):\n        \"\"\" Return the string[s] for a group[s]\n        if only one group is provided, a string is returned\n        if multiple groups are provided, a tuple of strings is returned\n        \"\"\"\n        ret = []\n        if ( len(args) > 0 ):\n            for index in args:\n                if type(index) is str:\n                    if self._namedGroups is not None:\n                        if ( index not in self._namedGroups.keys() ):\n                            raise ReIndexError()\n                        ret.append( self._obj[self._namedGroups[index]] )\n                    else:\n                        raise NotImplementedError(\"No NamedGroups Available\");\n                else:\n                    if ( index >= len(self._obj) ):\n                        # js will return an 'undefined' and we\n                        # want this to return an index error\n                        # Built-in Exceptions not defined ?\n                        raise ReIndexError()\n                    ret.append(self._obj[index])\n        else:\n            ret.append(self._obj[0])\n\n        if ( len(ret) == 1 ):\n            return(ret[0])\n        else:\n            return(tuple(ret))\n\n    def groups(self, default = None):\n        \"\"\" Get all the groups in this match. Replace any\n        groups that did not contribute to the match with default\n        value.\n        \"\"\"\n        if ( len(self._obj) > 1 ):\n            ret = self._obj[1:]\n            return(tuple([x if x is not None else default for x in ret]))\n        else:\n            return(tuple())\n\n    def groupdict(self, default = None):\n        \"\"\" The concept of named captures doesn't exist\n        in javascript so this will likely never be implemented.\n        For the python translated re we will have a group dict where\n        possible.\n        \"\"\"\n        if ( self._namedGroups is not None ):\n            ret = {}\n            for gName, gId in self._namedGroups.items():\n                value = self._obj[gid]\n                ret[gName] = value if value is not None else default\n            return(ret)\n        else:\n            # JS Only does not implement this\n            raise NotImplementedError(\"No NamedGroups Available\")\n\n    def start(self, group = 0):\n        \"\"\" Find the starting index in the string for the passed\n        group id or named group string.\n        @param group\n          if the type of group is a str, then the named groups dict\n            is searched for a matching string.\n          if the type of group is an int, then the groups are\n            indexed starting with 0 = entire match, and 1,... are\n            the indices of the matched sub-groups\n        \"\"\"\n        gId = 0\n        if ( type(group) is str ):\n            if ( self._namedGroups is not None):\n                if ( group not in self._namedGroups.keys() ):\n                    raise ReIndexError()\n                gId = self._namedGroups[group]\n            else:\n                raise NotImplementedError(\"No NamedGroups Available\")\n        else:\n            gId = group\n\n        if ( gId >= len(self._obj) ):\n            raise ReIndexError()\n\n        if ( gId == 0 ):\n            return(self._obj.index)\n        else:\n            # We don't really have a good way to do\n            # this in javascript. so we will attempt\n            # to match the string we found as a\n            # sub position in the main string - this\n            # isn't perfect though because you could\n            # create a capture that only matches on\n            # the last in a group - this is a difficult\n            # problem to solve without completely\n            # re-writing the regex engine from scratch.\n            if ( self._obj[gId] is not None ):\n                r = compile(escape(self._obj[gId]), self._re.flags)\n                m = r.search(self._obj[0])\n                if m:\n                    return(self._obj.index + m.start())\n                else:\n                    raise Exception(\"Failed to find capture group\")\n            else:\n                # This capture did not contribute the match.\n                return(-1)\n\n    def end(self, group = 0):\n        \"\"\" Find the ending index in the string for the passed\n        group id or named group string.\n        @param group\n          if the type of group is a str, then the named groups dict\n            is searched for a matching string.\n          if the type of group is an int, then the groups are\n            indexed starting with 0 = entire match, and 1,... are\n            the indices of the matched sub-groups\n        \"\"\"\n        gId = 0\n        if ( type(group) is str ):\n            if ( self._namedGroups is not None):\n                if ( group not in self._namedGroups.keys() ):\n                    raise ReIndexError()\n                gId = self._namedGroups[group]\n            else:\n                raise NotImplementedError(\"No NamedGroups Available\")\n        else:\n            gId = group\n\n        if ( gId >= len(self._obj) ):\n            raise ReIndexError()\n\n        if ( gId == 0 ):\n            return( self._obj.index + len(self._obj[0]))\n        else:\n            # We don't really have a good way to do\n            # this in javascript. so we will attempt\n            # to match the string we found as a\n            # sub position in the main string - this\n            # isn't perfect though because you could\n            # create a capture that only matches on\n            # the last in a group - this is a difficult\n            # problem to solve without completely\n            # re-writing the regex engine from scratch.\n            if ( self._obj[gId] is not None ):\n                r = compile(escape(self._obj[gId]), self._re.flags)\n                m = r.search(self._obj[0])\n                if m:\n                    return(self._obj.index + m.end())\n                else:\n                    raise Exception(\"Failed to find capture group\")\n            else:\n                # This capture did not contribute the match.\n                return(-1)\n\n    def span(self, group = 0):\n        \"\"\" Find the start and end index in the string for the passed\n        group id or named group string.\n        @param group\n          if the type of group is a str, then the named groups dict\n            is searched for a matching string.\n          if the type of group is an int, then the groups are\n            indexed starting with 0 = entire match, and 1,... are\n            the indices of the matched sub-groups\n        @return tuple of (start, end)\n        \"\"\"\n        return( (self.start(group), self.end(group)) )\n\nclass Regex(object):\n    \"\"\" Regular Expression Object\n    \"\"\"\n    def __init__(self, pattern, flags):\n        \"\"\" Initial the Regex Object\n        @param pattern - javascript regular expression pattern as a string\n        @param flags - string of javascript flags for the subsequently\n           created RegExp object.\n        \"\"\"\n        if ( not ((flags & ASCII) > 0) ):\n            flags |= UNICODE\n\n        self._flags = flags\n        self._jsFlags, self._obj = self._compileWrapper(pattern, flags)\n        self._jspattern = pattern\n        # For this regex object pypattern and jspattern are the\n        # same.\n        self._pypattern = pattern\n\n        # we will determine groups by using another regex\n        # that tacks on an empty match.\n        _, groupCounterRegex = self._compileWrapper(pattern + '|', flags)\n        self._groups = groupCounterRegex.exec('').length-1\n        # Javascript does not have named captures so this\n        # will never have content in js only mode\n        self._groupindex = None\n\n    # Read-only Properties\n    def _getPattern(self):\n        ret = self._pypattern.replace('\\\\', '\\\\\\\\')\n        return(ret)\n    def _setPattern(self, val):\n        raise AttributeError(\"readonly attribute\")\n    pattern = property(_getPattern, _setPattern)\n\n    def _getFlags(self):\n        return(self._flags)\n    def _setFlags(self, val):\n        raise AttributeError(\"readonly attribute\")\n    flags = property(_getFlags, _setFlags)\n\n    def _getGroups(self):\n        return(self._groups)\n    def _setGroups(self, val):\n        raise AttributeError(\"readonly attribute\")\n    groups = property(_getGroups, _setGroups)\n\n    def _getGroupIndex(self):\n        if ( self._groupindex is None ):\n            return({})\n        else:\n            return(self._groupindex)\n    def _setGroupIndex(self, val):\n        raise AttributeError(\"readonly attribute\")\n    groupindex = property(_getGroupIndex, _setGroupIndex)\n\n    def _compileWrapper(self, pattern, flags = 0):\n        \"\"\" This function wraps the creation of the the\n        regular expresion so that we can catch the\n        Syntax Error exception and turn it into a\n        Python Exception\n        \"\"\"\n        jsFlags = self._convertFlags(flags)\n\n        rObj = None\n        errObj = None\n        # The Exceptions need to be converted to python exceptions\n        # in order to propagate appropriately\n        __pragma__('js', '{}',\n                   '''\n                   try {\n                     rObj = new RegExp(pattern, jsFlags)\n                   } catch( err ) {\n                     errObj = err\n                   }\n                   ''')\n\n        if ( errObj is not None ):\n            raise error(errObj.message, errObj, pattern, flags)\n\n        return(jsFlags, rObj)\n\n    def _convertFlags(self, flags):\n        \"\"\" Convert the Integer map based flags to a\n        string list of flags for js\n        \"\"\"\n        bitmaps = [\n            (DEBUG , \"\"),\n            (IGNORECASE, \"i\"),\n            (MULTILINE, \"m\"),\n            (STICKY, \"y\"),\n            (GLOBAL, \"g\"),\n            (UNICODE, \"u\"),\n        ]\n        ret = \"\".join( [x[1] for x in bitmaps if (x[0] & flags) > 0] )\n        return(ret)\n\n    def _getTargetStr(self, string, pos, endpos):\n        \"\"\" Given an start and endpos, slice out a target string.\n        \"\"\"\n        endPtr = len(string)\n        if ( endpos is not None ):\n            if ( endpos < endPtr):\n                endPtr = endpos\n        if ( endPtr < 0 ):\n            endPtr = 0\n        ret = string[pos:endPtr]\n        return(ret)\n\n    def _patternHasCaptures(self):\n        \"\"\" Check if the regex pattern contains a capture\n        necessary to make split behave correctly\n        \"\"\"\n        return(self._groups > 0)\n\n    def search(self, string, pos=0, endpos=None):\n        \"\"\" Search through a string for matches to\n        this regex object. @see the python docs\n        \"\"\"\n        if ( endpos is None ):\n            endpos = len(string)\n        # @note - pos/endpos don't operate like a slice\n        #       here - we need to search complete string and then\n        #       reject if the match happens outside of pos:endpos\n        rObj = self._obj\n        m = rObj.exec(string)\n        if m:\n            if ( m.index < pos or m.index > endpos ):\n                return(None)\n            else:\n                # Valid match we will create a match object\n                return( Match(m, string, pos, endpos, self, self._groupindex))\n        else:\n            return(None)\n\n    def match(self, string, pos=0, endpos = None):\n        \"\"\" Match this regex at the beginning of the passed\n        string. @see the python docs\n        \"\"\"\n        target = string\n        if ( endpos is not None ):\n            target = target[:endpos]\n        else:\n            endpos = len(string)\n\n        rObj = self._obj\n        m = rObj.exec(target)\n        if m:\n            # Match only at the beginning\n            if ( m.index == pos ):\n                return( Match(m, string, pos, endpos, self, self._groupindex))\n            else:\n                return(None)\n        else:\n            return(None)\n\n    def fullmatch(self, string, pos=0, endpos = None):\n        \"\"\" Match the entirety of the passed string to this regex\n        object. @see the python docs\n        \"\"\"\n        target = string\n        strEndPos = len(string)\n        if ( endpos is not None ):\n            target = target[:endpos]\n            strEndPos = endpos\n\n        rObj = self._obj\n        m = rObj.exec(target)\n        if m:\n            obsEndPos = (m.index+len(m[0]))\n            if ( m.index == pos and obsEndPos == strEndPos ):\n                return( Match(m, string, pos, strEndPos, self, self._groupindex))\n            else:\n                return(None)\n        else:\n            return(None)\n\n    def split(self, string, maxsplit = 0):\n        \"\"\" Split the passed string on each match of this regex\n        object. If the regex contains captures, then the match\n        content is included as a separate item. If no captures are\n        in the regex, then only the non-matching split content is\n        returned. @see the python docs\n        @param maxsplit max number of times to split the string\n          at a matching substring.\n        @return list of sub-strings\n        \"\"\"\n        # JS split is slightly different from Python\n        # the \"limit\" arg limits the number of elements\n        # returned in the list - it doesn't limit the number of\n        # splits.\n\n        if ( maxsplit < 0 ):\n            return([string])\n\n        mObj = None\n        rObj = self._obj\n        if ( maxsplit == 0 ):\n            mObj = string.split(rObj)\n            return(mObj)\n        else:\n            # the split limit parameter in js does not behave like\n            # the maxsplit parameter in python - hence we need to\n            # do this manually.\n            # @todo - make this better handle the flags\n            flags = self._flags\n            flags |= GLOBAL\n\n            _, rObj = self._compileWrapper(self._jspattern, flags)\n            ret = []\n            lastM = None\n            cnt = 0\n            for i in range(0, maxsplit):\n                m = rObj.exec(string)\n                if m:\n                    cnt += 1\n                    if ( lastM is not None ):\n                        # subsequent match\n                        start = lastM.index + len(lastM[0])\n                        head = string[start:m.index]\n                        ret.append(head)\n                        if ( len(m) > 1 ):\n                            ret.extend(m[1:])\n                    else:\n                        # First match\n                        head = string[:m.index]\n                        ret.append(head)\n                        if ( len(m) > 1 ):\n                            ret.extend(m[1:])\n                    lastM = m\n                else:\n                    break\n\n            if ( lastM is not None ):\n                endPos = lastM.index + len(lastM[0])\n                end = string[endPos:]\n                ret.append(end)\n\n            return(ret)\n\n    def _findAllMatches(self, string, pos = 0, endpos = None):\n        target = self._getTargetStr(string, pos, endpos)\n\n        # Unfortunately, js RegExp.match does not behave\n        # like findall behaves in python - it doesn't\n        # pull out 'captures' like python expects so we\n        # are going to use RegExp.exec instead of match\n        flags = self._flags\n        flags |= GLOBAL\n\n        _, rObj = self._compileWrapper(self._jspattern, flags)\n        ret = []\n        while( True ):\n            m = rObj.exec(target)\n            if m:\n                ret.append(m)\n            else:\n                break\n        return(ret)\n\n    def findall(self, string, pos = 0, endpos = None):\n        \"\"\" Find All the matches to this regex in the passed string\n        @return either:\n          List of strings of the matched regex has 1 or 0 capture\n            groups\n          List of elements that are each a list of the groups matched\n            at each location in the string.\n        @see the python docs\n        \"\"\"\n        mlist = self._findAllMatches(string, pos, endpos)\n\n        def mSelect(m):\n            if ( len(m) > 2 ):\n                # Captures Present and we need to\n                # convert to a tuple\n                return(tuple(m[1:]))\n            elif ( len(m) == 2 ):\n                # 1 Capture\n                return(m[1])\n            else:\n                # No captures\n                return(m[0])\n\n        ret = map(mSelect, mlist)\n\n        return(ret)\n\n    def finditer(self, string, pos, endpos = None):\n        \"\"\" Like findall but returns an iterator instead of\n        a list.\n        @see the python docs\n        \"\"\"\n        # @note - Transcrypt compiled with `-e 5` does not have\n        #    iterator support at this point. Only `-e 6` has\n        #    iterator support.\n        __pragma__ ('ifdef', '__esv5__')\n        raise NotImplementedError(\"No Iterator Support in es5\")\n        __pragma__('else')\n        mlist = self._findAllMatches(string, pos, endpos)\n        ret = map(lambda m: Match(m, string, 0, len(string), self, self._groupindex), mlist)\n        return( iter(ret) )\n        __pragma__('endif')\n\n    def sub(self, repl, string, count = 0):\n        \"\"\" Substitude each match of this regex in the passed string\n        with either:\n          if repl is of type string,\n             replace with repl\n          if repl is a callable object, then the returned value\n            from repl(m) where m is the match object at a particular\n            point in the string.\n        @see the python docs\n        @return the augmented string with substitutions\n        \"\"\"\n        ret,_ = self.subn(repl, string, count)\n        return(ret)\n\n    def subn(self, repl, string, count = 0):\n        \"\"\" Similar to sub except that instead of just returning the\n        augmented string, it returns a tuple of the augmented string\n        and the number of times that the replacement op occured.\n        (augstr, numreplacements)\n        @see the python docs\n        \"\"\"\n        # For this we are going to use the 'exec' method\n        # because the 'replace' method in javascript is broken\n        # for what we are trying do. There is no way to get\n        # the function callback concept to work.\n        flags = self._flags\n        flags |= GLOBAL\n\n        _, rObj = self._compileWrapper(self._jspattern, flags)\n        ret = \"\"\n        totalMatch = 0\n        lastEnd = -1\n        while(True):\n            if (count > 0):\n                if ( totalMatch >= count ):\n                    if ( lastEnd < 0 ):\n                        # This is an odd case - if we got\n                        # here it means there is a bug in our code.\n                        return(ret,totalMatch)\n                    else:\n                        ret += string[lastEnd:m.index]\n                        return(ret,totalMatch)\n\n            m = rObj.exec(string)\n            if m:\n                if ( lastEnd < 0 ):\n                    # first match\n                    ret += string[:m.index]\n                else:\n                    # subsequent match\n                    ret += string[lastEnd:m.index]\n\n                if callable(repl):\n                    content = repl(Match(m, string, 0, len(string), self, self._groupindex))\n                    ret += content\n                else:\n                    ret += repl\n\n                totalMatch+=1\n                # Update the last end so we know where to start\n                # copying from on the next pass\n                lastEnd = m.index + len(m[0])\n            else:\n                # Failed to match means that there are no more\n                # matches in the string\n                if ( lastEnd < 0 ):\n                    # No matches were found - we return string\n                    # unmolested\n                    return(string, 0)\n                else:\n                    ret += string[lastEnd:]\n                    return(ret,totalMatch)\n\n\nclass PyRegExp(Regex):\n    \"\"\" Python Regular Expression object which translates a python\n    regex syntax string into a format that can be passed to the\n    js regex engine.\n    \"\"\"\n    def __init__(self, pyPattern, flags):\n        \"\"\"\n        @pattern Python Regex String\n        @pattern flags bit flags passed by the user.\n        \"\"\"\n        jsTokens, inlineFlags, namedGroups, nCapGroups, n_splits = translate(pyPattern)\n        flags |= inlineFlags\n\n        jsPattern = ''.join(jsTokens)\n        Regex.__init__(self, jsPattern, flags)\n        self._pypattern = pyPattern\n\n        self._nsplits = n_splits\n        self._jsTokens = jsTokens\n        # nCapGroups = the same as self.groups defined in the\n        #   base class.\n        self._capgroups = nCapGroups\n        self._groupindex = namedGroups\n\ndef compile(pattern, flags = 0):\n    \"\"\" Compile a regex object and return\n    an object that can be used for further processing.\n    \"\"\"\n    if ( flags & JSSTRICT ):\n        p = Regex(pattern, flags)\n    else:\n        p = PyRegExp(pattern, flags)\n    return(p)\n\ndef search(pattern, string, flags = 0):\n    \"\"\" Search a string for a particular matching pattern\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.search(string) )\n\ndef match(pattern, string, flags = 0):\n    \"\"\" Match a string for a particular pattern\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.match(string) )\n\ndef fullmatch(pattern, string, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.fullmatch(string) )\n\ndef split(pattern, string, maxsplit = 0, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.split(string, maxsplit) )\n\ndef findall(pattern, string, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.findall(string) )\n\ndef finditer(pattern, string, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.finditer(string) )\n\ndef sub(pattern, repl, string, count = 0, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.sub(repl, string, count) )\n\ndef subn(pattern, repl, string, count = 0, flags = 0):\n    \"\"\"\n    \"\"\"\n    p = compile(pattern, flags)\n    return( p.subn(repl, string, count) )\n\ndef escape(string):\n    \"\"\" Escape a passed string so that we can send it to the\n    regular expressions engine.\n    \"\"\"\n    ret = None\n    def replfunc(m):\n        if ( m[0] == \"\\\\\" ):\n            return(\"\\\\\\\\\\\\\\\\\")\n        else:\n            return(\"\\\\\\\\\" + m[0])\n\n    # @note - I had an issue getting replfunc to be called in\n    #        javascript correctly when I didn't use this pragma\n    #        not sure if I was just doing it wrong or what\n    __pragma__(\n        'js', '{}',\n        '''\n        var r = /[^A-Za-z\\d]/g;\n        ret = string.replace(r, replfunc);\n        ''')\n    if ( ret is not None ):\n        return(ret)\n    else:\n        raise Exception(\"Failed to escape the passed string\")\n\ndef purge():\n    \"\"\" I think this function is unnecessary but included to keep interface\n    consistent.\n    \"\"\"\n    pass\n"
	],
	"mappings": "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AGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAMA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}