{
	"version": 3,
	"file": "/home/steinar/source/Transcrypt/transcrypt/modules/re/__javascript__/re.translate.mod.js",
	"sources": [
		"/home/steinar/source/Transcrypt/transcrypt/modules/re/translate.py"
	],
	"sourcesContent": [
		"# Python RegExp Syntax to Javascript RegExp Syntax Translator\n# This code was pulled from the repository at:\n#   https://github.com/GULPF/rescrypt\n# Original license was MIT but was converted to Apache v2 for\n# ease of integrating with the Transcrypt project\n#\n\n\n__pragma__ ('tconv')\n\nVERBOSE = False\n\nMAX_SHIFTREDUCE_LOOPS = 1000\n\nstringFlags = 'aiLmsux'\n\n# Represents a regex group (e.g /()/, /(?:)/ /(?=), etc).\n# `start` and `end` is the index of the groups start and end token in the token list.\nclass Group:\n    def __init__(self, start, end, klass):\n        self.start = start\n        self.end = end\n        self.klass = klass\n\n    def __repr__(self):\n        return str((self.start, self.end, self.klass))\n\n\n# Generates a list of `Group`s from a token list.\ndef generateGroupSpans(tokens):\n    groupInfo = []\n\n    idx = 0\n    for token in tokens:\n        if token.name.startswith('('):\n            groupInfo.append(Group(idx, None, token.name))\n        elif token.name == ')':\n            for group in reversed(groupInfo):\n                if group.end is None:\n                    group.end = idx\n        idx += 1\n    return groupInfo\n\n\ndef countCaptureGroups(tokens):\n    groupInfo = generateGroupSpans(tokens)\n    count = 0\n\n    for token in tokens:\n        if token.name == '(':\n            count += 1\n\n    return count\n\n\n# Get the `Group` for a capture group with a given id or name.\ndef getCaptureGroup(groupInfo, namedGroups, groupRef):\n    try:\n        id = int(groupRef)\n    except:\n        id = namedGroups[groupRef]\n    search = 0\n    for group in groupInfo:\n        if group.klass == '(':\n            search += 1\n            if search == id:\n                return group\n\n\n# Regex conditionals is implemented by splitting the regex into two parts,\n# one for the if case and one for the else case.\n# Example: if the input is (a)?(b)?(?(1)a|c)(?(2)b|d),\n# the first conditional will cause it to split into these parts:\n# `()(b)?c(?(2)b|d)` and `(a)(b)?a(?(2)b|d)`\n# The second conditional will then cause each part to split into two, creating four parts in total:\n# `()()cd`, `()(b)cb`, `(a)()ad` and `(a)(b)ab`\n# The parts are then merged into a single regex: `part1|part2|part3|part4`.\n# TODO: This causes the group indexes to be messed up. To fix it, group indexes must be modified with `% len(groups) + 1`.\ndef splitIfElse(tokens, namedGroups):\n    variants = []\n    groupInfo = generateGroupSpans(tokens)\n\n    for group in groupInfo:\n        if group.klass == '(?<':\n            iff = tokens[:]\n            els = tokens[:]\n            conStart = group.start\n            conEnd   = group.end\n\n            ref = tokens[conStart + 1].name\n            captureGroup = getCaptureGroup(groupInfo, namedGroups, ref)\n            captureGroupModifier = tokens[captureGroup.end + 1]\n\n            if captureGroupModifier.name in ['?', '*'] or captureGroupModifier.name.startswith('{0,'):\n                if captureGroupModifier.name == '?':\n                    iff[captureGroup.end + 1] = None\n                elif captureGroupModifier.name == '*':\n                    iff[captureGroup.end + 1] = Token('+')\n                elif captureGroupModifier.name.startswith('{0,'):\n                    iff[captureGroup.end + 1].name[0:3] = '{1,'\n                els[captureGroup.end + 1] = None\n\n                hasElse = False\n                for idx in range(conStart, conEnd):\n                    if tokens[idx].name == '|':\n                        hasElse = True\n                        els.pop(conEnd)\n                        iff[idx:conEnd + 1] = []\n                        els[conStart:idx + 1] = []\n                        break\n\n                if not hasElse:\n                    els[conStart:conEnd + 1] = []\n                    iff.pop(conEnd)\n\n                iff[conStart:conStart + 3] = []\n                els[captureGroup.start:captureGroup.end + 1] = [Token('('), Token(')')]\n                iff.remove(None)\n                els.remove(None)\n                variants.append(iff)\n                variants.append(els)\n\n            else:  # the easy case - 'else' is impossible\n                pastIff = False\n                for idx in range(conStart, conEnd):\n                    if iff[idx].name == '|':\n                        iff = tokens[:idx]\n                        iff.extend(tokens[conEnd + 1:])\n                        break\n                iff[conStart:conStart + 3] = []\n                variants.append(iff)\n            break\n\n    if not variants:\n        return [tokens]\n\n    allVariants = []\n    for variant in variants:\n        allVariants.extend(splitIfElse(variant, namedGroups))\n    return allVariants\n\n\nclass Token:\n    def __init__(self, name, paras=None, pure=False):\n        if paras is None:\n            paras = []\n        self.name  = name\n        self.paras = paras\n        self.pure = pure\n        # tmp until I have thought of something better\n        self.isModeGroup = False\n\n    def __repr__(self):\n        return self.name\n\n    def resolve(self):\n        paras = ''\n        for para in self.paras:\n            paras += str(para)\n\n        return self.name + paras\n\n\ndef shift(stack, queue):\n    done = not bool(queue)\n    if not done:\n        stack.append(Token(queue[0], [], True))\n        queue = queue[1:]\n    return stack, queue, done\n\n\n# Shift-reduce parser. Creates the next state of the stack & queue.\ndef shiftReduce(stack, queue, namedGroups, flags):\n    done = False\n    high = len(stack) - 1\n\n    if len(stack) < 2:\n        stack, queue, done = shift(stack, queue)\n        return stack, queue, flags, done\n\n    s0 = stack[high]     if len(stack) > 0 else Token('')\n    s1 = stack[high - 1] if len(stack) > 1 else Token('')\n\n    if VERBOSE:\n        for token in stack:\n            console.log(token.resolve(), '\\t', end='')\n        console.log('')\n\n    if s1.name == '\\\\':\n        if s0.name == 'A':\n            stack[-2:] = [Token('^')]\n\n        elif s0.name == 'a':\n            stack[-2:] = [Token('\\\\07')]\n\n        elif s0.name == 'Z':\n            stack[-2:] = [Token('$')]\n\n        else:\n            stack[-2:] = [Token('\\\\' + s0.name)]\n\n    elif s0.name == '$' and s0.pure:\n        stack.pop()\n        stack.extend([Token('(?='), Token('\\\\n'), Token('?'), Token('$'), Token(')')])\n\n    elif s1.name == '{':\n        if s0.name == ',' and len(s1.paras) == 0:\n            s1.paras.append('0')\n            s1.paras.append(',')\n        else:\n            if s0.name == '}':\n                s1.paras.append('}')\n                s1.name = s1.resolve()\n                s1.paras = []\n            else:\n                s1.paras.append(s0.name)\n\n        stack = stack[:-1]\n\n    elif s1.name == '[' and s0.name == '^':\n        stack[-2:] = [Token('[^')]\n\n    elif s1.name == '(' and s0.name == '?':\n        stack[-2:] = [Token('(?')]\n\n    elif s1.name in ['*', '+', '?'] and s0.name == '?':\n        stack[-2:] = [Token(s1.name + '?')]\n\n    elif s1.isModeGroup and s0.name == ')':\n        stack = stack[:-2]\n\n    elif s1.name == '(?':\n        if s0.name in stringFlags:\n            if s0.name == 'i':\n                flags |= re.IGNORECASE\n            elif s0.name == 'L':\n                flags |= re.LOCALE\n            elif s0.name == 'm':\n                flags |= re.MULTILINE\n            elif s0.name == 's':\n                flags |= re.DOTALL\n            elif s0.name == 'u':\n                flags |= re.UNICODE\n            elif s0.name == 'x':\n                flags |= re.VERBOSE\n            elif s0.name == 'a':\n                flags |= re.ASCII\n\n            stack.pop()\n            s1.isModeGroup = True\n\n        else:\n            if s0.name == '(':\n                s0.name = '<'\n\n            newToken = Token('(?' + s0.name)\n            stack[-2:] = [newToken]\n\n    elif s1.name == '(?<':\n        if s0.name == ')':\n            stack[-1:] = [Token(''.join(s1.paras)), Token('>')]\n            s1.paras = []\n        else:\n            s1.paras.append(s0.name)\n            stack.pop()\n\n    elif s1.name == '(?P':\n        stack[-2:] = [Token('(?P' + s0.name)]\n\n    elif s1.name == '(?P<':\n        if s0.name == '>':\n            # todo: don't count every time, just keep track of it over time\n            namedGroups[''.join(s1.paras)] = countCaptureGroups(stack) + 1\n            stack[-2:] = [Token('(')]\n        else:\n            s1.paras.append(s0.name)\n            stack.pop()\n\n    elif s1.name == '(?P=':\n        if s0.name == ')':\n            stack[-2:] = [Token('\\\\' + str(namedGroups[s1.paras[0]]))]\n        elif not s1.paras:\n            s1.paras.append(s0.name)\n            stack.pop()\n        else:\n            s1.paras[0] += s0.name\n            stack.pop()\n\n    elif s1.name == '(?#':\n        if s0.name == ')':\n            stack = stack[:-2]\n        else:\n            stack = stack[:-1]\n\n    else:\n        stack, queue, done = shift(stack, queue)\n\n    return stack, queue, flags, done\n\n\n# Takes a re-regex and returns a js-regex.\n# TODO: Returns way to many values.\ndef translate(rgx):\n    # can't import as normal because it's a circular dependency\n    import re\n    stack = []\n    queue = list(rgx)\n\n    flags = 0\n    namedGroups = dict()\n\n    nloop = 0\n\n    while True:\n        nloop += 1\n        if nloop > MAX_SHIFTREDUCE_LOOPS:\n            raise Exception()\n\n        stack, queue, flags, done = shiftReduce(stack, queue, namedGroups, flags)\n        if done:\n            break\n\n    variants = splitIfElse(stack, namedGroups)\n    n_splits = len(variants)\n\n    final = []\n    for i in range(0, len(variants)):\n        final.extend(variants[i])\n        if i < len(variants) - 1:\n            final.append(Token('|'))\n    stack = final\n\n    groupInfo = generateGroupSpans(stack)\n    resolvedTokens = []\n\n    for token in stack:\n        stringed = token.resolve()\n        if (flags & re.DOTALL) and stringed == '.':\n            stringed = '[\\s\\S]'\n        resolvedTokens.append(stringed)\n    return resolvedTokens, flags, namedGroups, countCaptureGroups(stack), n_splits\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoVA;AA1UA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}